# GPT-Researcher Security Vulnerability Report

## Issue

**gpt-researcher's file deletion endpoint uses `os.path.basename()` for path sanitization, which lacks defense-in-depth security measures like null byte checking, symlink detection, and explicit bounds validation.**

## Vulnerable Code

**File**: `backend/server/server_utils.py:248-256`

```python
async def handle_file_deletion(filename: str, DOC_PATH: str) -> JSONResponse:
    file_path = os.path.join(DOC_PATH, os.path.basename(filename))
    if os.path.exists(file_path):
        os.remove(file_path)
        print(f"File deleted: {file_path}")
        return JSONResponse(content={"message": "File deleted successfully"})
    else:
        print(f"File not found: {file_path}")
        return JSONResponse(status_code=404, content={"message": "File not found"})
```

**Endpoint**: `DELETE /files/{filename}` (server.py:194-196)

## Proof of Concept

### Test Case 1: Path Traversal Attempt (Mitigated)

```bash
# Attempt to delete /etc/passwd via path traversal
curl -X DELETE http://localhost:8000/files/../../../etc/passwd

# What happens:
# - basename("../../../etc/passwd") → "passwd"
# - Final path: /my-docs/passwd (NOT /etc/passwd)
# - Result: SAFE - path traversal blocked by basename()
```

```python
# Demonstration
>>> import os
>>> DOC_PATH = "/my-docs"
>>> filename = "../../../etc/passwd"
>>> os.path.join(DOC_PATH, os.path.basename(filename))
'/my-docs/passwd'  # Confined to DOC_PATH ✓
```

### Test Case 2: Null Byte Injection (Unprotected)

```python
# Null byte can bypass extension checks (on older systems)
filename = "safe.txt\x00.php"

# Current code doesn't check:
file_path = os.path.join(DOC_PATH, os.path.basename(filename))
# → /my-docs/safe.txt\x00.php

# On some systems, file operations stop at null byte:
os.remove(file_path)  # Might delete "safe.txt" instead
```

### Test Case 3: Symlink Attack (Unprotected)

```bash
# If attacker can create symlink in DOC_PATH:
cd /path/to/DOC_PATH
ln -s /etc/passwd malicious_link

# Then request deletion:
curl -X DELETE http://localhost:8000/files/malicious_link

# Current code doesn't check if it's a symlink
# → Could delete /etc/passwd if symlink is followed
```

## Impact Assessment

| Risk Factor | Status | Severity |
|------------|--------|----------|
| **Basic Path Traversal** | ✅ MITIGATED | LOW |
| **Null Byte Injection** | ❌ UNPROTECTED | LOW-MEDIUM |
| **Symlink Following** | ❌ UNPROTECTED | MEDIUM |
| **TOCTOU Race Condition** | ❌ UNPROTECTED | LOW |

**Overall Severity**: LOW (basic protection exists)

**Exploitability**: LOW (requires specific conditions)

## Execution Screenshot

> [Screenshot placeholder - Running vulnerability test]

```bash
# Setup
cd /srv/home/shiqiu/Anewbenchmark/gpt-researcher
docker compose up -d gpt-researcher

# Test basic path traversal
curl -X DELETE http://localhost:8009/files/../../../etc/passwd

# Expected: 404 File not found (looking for /my-docs/passwd)
```

> [Screenshot placeholder - Verification of mitigation]

## Recommended Fix

```python
from pathlib import Path

def sanitize_path(filename: str, root_path: str) -> Path:
    """Secure path sanitization with defense-in-depth"""
    # 1. Check for null bytes
    NULL_BYTES = ["\0", "\000", "\x00", r"\z", "\u0000", "%00"]
    for null_byte in NULL_BYTES:
        if null_byte in filename:
            raise ValueError("Null byte detected in filename")

    # 2. Extract basename and resolve
    root = Path(root_path).resolve()
    safe_name = Path(filename).name
    full_path = (root / safe_name).resolve()

    # 3. Explicit bounds checking
    if not full_path.is_relative_to(root):
        raise ValueError(f"Path outside workspace: {filename}")

    # 4. Symlink detection
    if full_path.is_symlink():
        target = full_path.resolve()
        if not target.is_relative_to(root):
            raise ValueError("Symlink points outside workspace")

    return full_path

async def handle_file_deletion_secure(filename: str, DOC_PATH: str) -> JSONResponse:
    try:
        file_path = sanitize_path(filename, DOC_PATH)

        if file_path.exists() and file_path.is_file():
            file_path.unlink()
            return JSONResponse(content={"message": "File deleted successfully"})

        return JSONResponse(
            status_code=404,
            content={"message": "File not found"}
        )
    except ValueError as e:
        return JSONResponse(
            status_code=400,
            content={"message": f"Invalid path: {str(e)}"}
        )
```

## Related Findings

### Document Processing (DOCX Upload)

**Issue**: gpt-researcher processes uploaded/downloaded DOCX files without comprehensive security validation.

**Status**: ZIP Slip vulnerability is MITIGATED by Python's `zipfile.extractall()` which automatically sanitizes paths.

```python
# Test Result:
with zipfile.ZipFile(malicious_docx, 'r') as zf:
    # Even with malicious entry: '../../../tmp/pwned.txt'
    zf.extractall('/extract_dir')
    # Result: /extract_dir/tmp/pwned.txt (NOT /tmp/pwned.txt) ✓
```

**Recommendation**: Add file type validation, size limits, and content scanning.

## Conclusion

The `handle_file_deletion` function uses `os.path.basename()` which provides basic protection against path traversal attacks, preventing deletion of files outside the DOC_PATH directory. However, it lacks defense-in-depth measures and should be hardened with explicit validation, null byte checking, and symlink detection as security best practices.

**Can construct end-to-end exploit**: NO - Primary attack vectors are mitigated by Python's built-in protections.

**Recommended Priority**: MEDIUM - Implement suggested fixes as defense-in-depth improvement.

---

**Report Date**: 2025-11-11
**Researcher**: Security Analysis Team
**Framework**: GPT-Researcher (Docker Environment)
