# GPT-Researcher Security Assessment

## Summary

**Finding**: Path traversal vulnerability in `handle_file_deletion` function (backend/server/server_utils.py:248-256) uses `os.path.basename()` for sanitization, which provides basic protection but lacks defense-in-depth security measures.

**Severity**: LOW (basic protection exists, but incomplete)

**Actual Risk**: Cannot delete files outside DOC_PATH due to basename() stripping directory components.

## Detailed Analysis

### 1. File Deletion Handler - Limited Path Traversal Risk

**Location**: `backend/server/server_utils.py:248-256`

**Vulnerable Code**:
```python
async def handle_file_deletion(filename: str, DOC_PATH: str) -> JSONResponse:
    file_path = os.path.join(DOC_PATH, os.path.basename(filename))
    if os.path.exists(file_path):
        os.remove(file_path)
        return JSONResponse(content={"message": "File deleted successfully"})
    else:
        return JSONResponse(status_code=404, content={"message": "File not found"})
```

**Why It's (Mostly) Safe**:
```python
# Test case 1: Path traversal attempt
>>> os.path.basename("../../../etc/passwd")
'passwd'
>>> os.path.join("/my-docs", os.path.basename("../../../etc/passwd"))
'/my-docs/passwd'  # Safe - confined to /my-docs

# Test case 2: Absolute path
>>> os.path.basename("/etc/passwd")
'passwd'
>>> os.path.join("/my-docs", os.path.basename("/etc/passwd"))
'/my-docs/passwd'  # Safe - confined to /my-docs
```

**Missing Security Measures**:
1. ❌ No null byte checking
2. ❌ No symlink detection
3. ❌ No explicit bounds validation
4. ❌ TOCTOU race condition (check-then-use)

**Example Attack Scenario** (unlikely to succeed):
```bash
# Attacker tries to delete /etc/passwd
curl -X DELETE http://localhost:8000/files/../../../etc/passwd

# What actually happens:
# - Server extracts basename: "passwd"
# - Constructs path: /my-docs/passwd
# - Deletes: /my-docs/passwd (if exists)
# Result: /etc/passwd is NOT affected
```

### 2. DOCX Processing - ZIP Slip Mitigated

**Location**: `gpt_researcher/document/online_document.py:36-87`

**Test Result**:
```python
# Python's zipfile.extractall() is SAFE
>>> zf.writestr('../../../tmp/pwned.txt', 'content')
>>> zf.extractall('/extract_dir')
# Result: /extract_dir/tmp/pwned.txt (NOT /tmp/pwned.txt)
```

**Conclusion**: Python's zipfile library automatically sanitizes paths during extraction. ZIP Slip attack is MITIGATED.

### 3. XXE (XML External Entity) - Inconclusive

**Potential Risk**: DOCX files contain XML that might be parsed unsafely.

**Test Result**: Basic XXE payload failed due to incomplete DOCX structure.

**Status**: Requires further investigation with properly formatted DOCX files.

## End-to-End Attack Assessment

### Scenario: Malicious Document via document_urls

**Attack Chain**:
```
User provides malicious URL
    ↓
OnlineDocumentLoader.load()
    ↓
_download_and_process(url) - downloads file
    ↓
UnstructuredWordDocumentLoader(file_path)
    ↓
partition_docx() - extracts and parses DOCX
    ↓
zipfile.extractall() - SAFE (sanitizes paths)
```

**Result**: Cannot achieve file write outside temp directory due to Python zipfile protections.

## Verified Security Status

| Attack Vector | Status | Notes |
|--------------|--------|-------|
| **Path Traversal (file deletion)** | ⚠️ LOW RISK | basename() provides basic protection |
| **Zip Slip (DOCX extraction)** | ✅ MITIGATED | Python zipfile is safe |
| **XXE (XML parsing)** | ❓ UNKNOWN | Needs proper DOCX structure |
| **Symlink Attack** | ⚠️ UNPROTECTED | No symlink checking |
| **Null Byte Injection** | ⚠️ UNPROTECTED | No null byte validation |

## Recommended Fixes

### Priority 1: Improve file_deletion validation

```python
from pathlib import Path

def sanitize_path(filename: str, root_path: str) -> Path:
    """Secure path validation with defense-in-depth"""
    # Check null bytes
    if '\0' in filename:
        raise ValueError("Null byte in filename")

    # Resolve paths
    root = Path(root_path).resolve()
    safe_name = Path(filename).name  # basename equivalent
    full_path = (root / safe_name).resolve()

    # Explicit bounds check
    if not full_path.is_relative_to(root):
        raise ValueError(f"Path outside workspace: {filename}")

    # Symlink detection
    if full_path.is_symlink():
        target = full_path.resolve()
        if not target.is_relative_to(root):
            raise ValueError("Symlink points outside workspace")

    return full_path

async def handle_file_deletion_secure(filename: str, DOC_PATH: str) -> JSONResponse:
    try:
        file_path = sanitize_path(filename, DOC_PATH)
        if file_path.exists() and file_path.is_file():
            file_path.unlink()
            return JSONResponse(content={"message": "File deleted successfully"})
        return JSONResponse(status_code=404, content={"message": "File not found"})
    except ValueError as e:
        return JSONResponse(status_code=400, content={"message": str(e)})
```

### Priority 2: Add input validation

```python
# Whitelist allowed file extensions
ALLOWED_EXTENSIONS = {'.pdf', '.txt', '.doc', '.docx', '.md'}

# File size limits
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB

# Validate before processing
if file_path.suffix not in ALLOWED_EXTENSIONS:
    raise ValueError(f"File type not allowed: {file_path.suffix}")
```

## Conclusion

**Can we construct an end-to-end injection?**

**NO** - The primary attack vectors (Zip Slip via DOCX) are mitigated by Python's built-in security features. The `handle_file_deletion` function uses `os.path.basename()` which, while not best practice, provides sufficient protection against basic path traversal attacks.

**Actual exploitability**: LOW

**Impact if exploited**: File deletion confined to DOC_PATH directory

**Recommended action**: Implement defense-in-depth improvements (null byte checking, symlink detection, explicit validation) as best practice, even though immediate risk is low.
